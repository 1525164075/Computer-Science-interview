## 3.31

### 3.14 tcp_tw_reuse 为什么默认是关闭的？

在TCP协议中，tcp_tw_reuse 是一个与TCP连接管理相关的内核参数，主要用于控制是否允许重用处于 TIME_WAIT 状态的TCP连接的端口。这个参数在高并发场景下（如服务器处理大量短连接）非常有用，可以优化端口资源的使用。

其实这题在变相问「**如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？**」

因为开启 tcp_tw_reuse 参数可以快速复用处于 TIME_WAIT 状态的 TCP 连接时，相当于缩短了 TIME_WAIT 状态的持续时间。

#### 1、什么是 TIME_WAIT 状态？

TCP 四次挥手过程，如下图：

![图片](D:/interview/网络/assets/e973a17cb5b1092085ca1bbcd7083559.png)

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1`的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSED_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务器收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

你可以看到，两个方向都需要**一个 FIN 和一个 ACK**，因此通常被称为**四次挥手**。

这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**

可以看到，TIME_WAIT 是「主动关闭方」断开连接时的最后一个状态，该状态会持续 ***2MSL(Maximum Segment Lifetime)\*** 时长，之后进入CLOSED 状态。

MSL 是由网络层的 IP 包中的 TTL 来保证的，TTL 是 IP 头部的一个字段，用于设置一个数据报可经过的路由器的数量上限。报文每经过一次路由器的转发，IP 头部的 TTL 字段就会减 1，减到 0 时报文就被丢弃。

MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。

**TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了**。

#### 2、为什么要设计 TIME_WAIT 状态？

设计 TIME_WAIT 状态，主要有两个原因：

- 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
- 保证「被动关闭连接」的一方，能被正确的关闭；

**1. 防止历史连接中的数据，被后面相同四元组的连接错误的接收；**

- **问题背景：** 在 TCP 连接关闭后，网络中可能仍然存在一些延迟到达的数据包，这些数据包属于刚刚关闭的连接。TCP 连接是由四元组（源 IP 地址、源端口号、目标 IP 地址、目标端口号）唯一确定的。如果一个连接关闭后很快又使用相同的四元组建立了一个新的连接，那么之前连接中延迟到达的数据包可能会被错误地认为是新连接的数据，从而导致数据混乱或者应用程序逻辑错误。
- **`TIME_WAIT` 的作用：** 处于 `TIME_WAIT` 状态的一方（通常是主动发起关闭的一方，即发送最后一个 ACK 的客户端）会等待一个 `2MSL`（Maximum Segment Lifetime）的时间。`MSL` 指的是报文段在网络中可以存活的最长时间。等待 `2MSL` 可以确保以下两点：
  - **网络中的所有延迟报文段都已过期：** 经过 `2MSL` 的时间，之前连接中任何可能在网络中滞留的数据包，包括数据段、控制报文段（如 FIN），都应该已经到达对端或者被网络丢弃。
  - **新的连接不会与旧连接的残留数据混淆：** 当 `TIME_WAIT` 状态结束后，即使使用相同的四元组建立新的连接，由于旧连接的所有报文段都已消失，新连接收到的数据肯定是属于本次连接的，避免了数据混淆的问题。
- **举例说明：** 假设客户端 A 和服务器 B 建立了一个连接，传输了一些数据后关闭了连接。此时，网络中可能还存在一些属于这个连接的数据包正在传输。如果客户端 A 立即使用相同的 IP 地址和端口号再次连接服务器 B，那么之前连接中延迟到达的数据包可能会在新连接建立后到达客户端 A，客户端 A 可能会错误地将这些旧数据当作新连接的数据进行处理。而有了 `TIME_WAIT` 状态，客户端 A 在关闭连接后会等待 `2MSL` 的时间，这段时间内所有旧连接的数据包都应该已经到达或者过期，当 `TIME_WAIT` 结束后再建立新连接，就不会出现接收到旧连接数据的错误了。

**2. 保证「被动关闭连接」的一方，能被正确的关闭；**

- **问题背景：** 在 TCP 四次挥手的最后一步，主动关闭连接的一方（通常是客户端）会发送一个 `ACK` 报文来确认被动关闭连接的一方（通常是服务器）发送的 `FIN` 报文。这个最后的 `ACK` 报文有可能在网络中丢失。
- **`TIME_WAIT` 的作用：** 如果最后一个 `ACK` 报文丢失，被动关闭连接的一方（服务器）没有收到这个确认，它会认为自己的 `FIN` 报文没有被正确接收，从而会重新发送 `FIN` 报文。处于 `TIME_WAIT` 状态的主动关闭连接方（客户端）会监听网络，如果收到服务器重发的 `FIN` 报文，它会再次发送 `ACK` 报文给服务器。这样，服务器就能收到确认，并正常进入 `CLOSE` 状态，完成连接的关闭。
- **如果主动关闭方没有 `TIME_WAIT` 会怎样：** 如果客户端在发送完最后一个 `ACK` 后立即关闭（进入 `CLOSE` 状态），那么一旦这个 `ACK` 丢失，服务器将无法收到确认，会一直停留在 `LAST_ACK` 状态，等待客户端的确认。由于客户端已经关闭，它不会再发送任何 `ACK` 报文，导致服务器的连接无法正常关闭，会一直占用资源。而有了 `TIME_WAIT` 状态，即使最后的 `ACK` 丢失，客户端在等待 `2MSL` 的时间内仍然处于监听状态，可以接收到服务器重发的 `FIN`，并再次发送 `ACK`，从而保证了被动关闭方能够被正确地关闭。

#### 3、tcp_tw_reuse 是什么？

在 Linux 操作系统下，TIME_WAIT 状态的持续时间是 60 秒，这意味着这 60 秒内，客户端一直会占用着这个端口。要知道，端口资源也是有限的，一般可以开启的端口为 32768~61000 ，也可以通过如下参数设置指定范围：

```text
 net.ipv4.ip_local_port_range
```

**如果客户端（主动关闭连接方）的 TIME_WAIT 状态过多**，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务器发起连接了，但是被使用的端口，还是可以继续对另外一个服务器发起连接的。

因此，客户端（主动关闭连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务器建立连接的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务器建立连接了。

不过，即使是在这种场景下，只要连接的是不同的服务器，端口是可以重复使用的，所以客户端还是可以向其他服务器发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。

好在，Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：

- net.ipv4.tcp_tw_reuse，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，**如果内核选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了**。所以该选项只适用于连接发起方。
- net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收，该参数在 **NAT 的网络下是不安全的**！

要使得上面这两个参数生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps=1（默认即为 1）。

#### 4、为什么 tcp_tw_reuse 默认是关闭的？

##### （1）第一个问题

我们知道开启 tcp_tw_reuse 的同时，也需要开启 tcp_timestamps，意味着可以用时间戳的方式有效的判断回绕序列号的历史报文。

但是，在看我看了防回绕序列号函数的源码后，发现对于 **RST 报文的时间戳即使过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的**。

下面 tcp_validate_incoming 函数就是验证接收到的 TCP 报文是否合格的函数，其中第一步就会进行 PAWS 检查，由 tcp_paws_discard 函数负责。

当 tcp_paws_discard 返回 true，就代表报文是一个历史报文，于是就要丢弃这个报文。但是在丢掉这个报文的时候，会先判断是不是 RST 报文，如果不是 RST 报文，才会将报文丢掉。也就是说，即使 RST 报文是一个历史报文，并不会被丢弃。

假设有这样的场景，如下图![img](D:/interview/网络/assets/0df2003d41ec0ef23844975a85cfb722.png)

过程如下：

- 客户端向一个还没有被服务端监听的端口发起了 HTTP 请求，接着服务端就会回 RST 报文给对方，很可惜的是 **RST 报文被网络阻塞了**。
- 由于客户端迟迟没有收到 TCP 第二次握手，于是重发了 SYN 包，与此同时服务端已经开启了服务，监听了对应的端口。于是接下来，客户端和服务端就进行了 TCP 三次握手、数据传输（HTTP应答-响应）、四次挥手。
- 因为**客户端开启了 tcp_tw_reuse，于是快速复用 TIME_WAIT 状态的端口，又与服务端建立了一个与刚才相同的四元组的连接**。
- 接着，**前面被网络延迟 RST 报文这时抵达了客户端，而且 RST 报文的序列号在客户端的接收窗口内，由于防回绕序列号算法不会防止过期的 RST，所以 RST 报文会被客户端接受了，于是客户端的连接就断开了**。

上面这个场景就是开启 tcp_tw_reuse 风险，**因为快速复用 TIME_WAIT 状态的端口，导致新连接可能被回绕序列号的 RST 报文断开了，而如果不跳过 TIME_WAIT 状态，而是停留 2MSL 时长，那么这个 RST 报文就不会出现下一个新的连接**。

##### （2）第二个问题

开启 tcp_tw_reuse 来快速复用 TIME_WAIT 状态的连接，如果第四次挥手的 ACK 报文丢失了，服务端会触发超时重传，重传第三次挥手报文，处于 syn_sent 状态的客户端收到服务端重传第三次挥手报文，则会回 RST 给服务端。如下图：

![img](D:/interview/网络/assets/tcp_tw_reuse第二个问题.drawio.png)

**如果此时客户端由于开启了 `tcp_tw_reuse` 并且满足了复用条件，恰好使用相同的四元组发起了一个新的连接（进入 `SYN_SENT` 状态）：**

- 客户端在 `SYN_SENT` 状态下（正在进行新的连接的三次握手），收到了服务端重传的 **来自上一个已关闭连接的 `FIN` 报文**。
- 对于处于 `SYN_SENT` 状态的 TCP 协议栈来说，收到一个与当前正在建立的连接无关的 `FIN` 报文，会认为这是一个异常情况。
- 根据 TCP 协议的规定，当一个处于 `SYN_SENT` 状态的连接收到一个不是期望的 `SYN+ACK` 报文时（这里收到了 `FIN`），通常会回应一个 **RST（Reset）报文** 给发送方（服务端）。服务端收到后，就会断开连接。