# 05-Vue的举例：列表功能

## 列表功能举例

### [#](https://web.qianguyihao.com/12-Vue基础/05-Vue的举例：列表功能.html#步骤-1-列表功能)步骤 1：列表功能

完整的代码如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .table {
            width: 800px;
            margin: 20px auto;
            border-collapse: collapse; /*这一行，不能少：表格的两边框合并为一条*/
        }

        .table th {
            background: #0094ff;
            color: white;
            font-size: 16px;
            border: 1px solid black;
            padding: 5px;

        }

        .table tr td {
            text-align: center;
            font-size: 16px;
            padding: 5px;
            border: 1px solid black;
        }
    </style>

    <script src="vue2.5.16.js"></script>
</head>

<body>

<div id="app">

    <table class="table">
        <th>编号</th>
        <th>名称</th>
        <th>创建时间</th>
        <th>操作</th>
        <tr v-for="item in list">
            <td>{{item.id}}</td>
            <td>{{item.name}}</td>
            <td>{{item.ctime}}</td>
            <td><a href="#">删除</a></td>
        </tr>
    </table>
</div>

</body>

<script>
    var vm = new Vue({
        el: '#app',
        data: {
            list: [{id: 1, name: '奔驰', ctime: new Date}, {id: 2, name: '大众', ctime: new Date}]
        }
    })

</script>

</html>
```

**代码分析**：数据是存放在data的list中的，将data中的数据通过`v-for`遍历给表格。

上方代码运行的效果：

![img](assets/20180401_1517.png)

### 步骤 2：无数据时，增加提示

如果list中没有数据，那么表格中就会只显示表头`<th>`，这样显然不太好看。

为此，我们需要增加一个`v-if`判断：当数据为空时，显示提示。如下：

```html
			<tr v-show="list.length == 0">
				<td colspan="4">列表无数据</td>
			</tr>
```

代码解释：`colspan="4"`指的是让当前这个`<td>`横跨4个单元格的位置。如下：

![img](assets/20180401_1535.png)

### [#](https://web.qianguyihao.com/12-Vue基础/05-Vue的举例：列表功能.html#步骤-3-item的添加)步骤 3：item的添加

具体实现步骤如下：

（1）用户填写的数据单独存放在data属性里，并采用`v-model`进行双向绑定。

（2）用户把数据填好后，点击add按钮。此时需要增加一个点击事件的方法，将data中的数据放到list中（同时，清空文本框中的内容）。

（3）将数据展示出来。`v-for`有个特点：当list数组发生改变后，vue.js就会自动调用`v-for`重新将数据生成，这样的话，就实现了数据的自动刷新。

完整的代码如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .table {
            width: 800px;
            margin: 20px auto;
            border-collapse: collapse; /*这一行，不能少：表格的两边框合并为一条*/
        }

        .table th {
            background: #0094ff;
            color: white;
            font-size: 16px;
            border: 1px solid black;
            padding: 5px;
        }

        .table tr td {
            text-align: center;
            font-size: 16px;
            padding: 5px;
            border: 1px solid black;
        }

        .form {
            width: 800px;
            margin: 20px auto;
        }

        .form button {
            margin-left: 10px;
        }
    </style>

    <script src="vue2.5.16.js"></script>
</head>

<body>

<div id="app">

    <div class="form">

        编号：<input type="text" v-model="formData.id">
        名称：<input type="text" v-model="formData.name">

        <button v-on:click="addData">添加</button>
    </div>

    <table class="table">
        <th>编号</th>
        <th>名称</th>
        <th>创建时间</th>
        <th>操作</th>
        <tr v-show="list.length == 0">
            <td colspan="4">列表无数据</td>
        </tr>
        <tr v-for="item in list">
            <td>{{item.id}}</td>
            <td>{{item.name}}</td>
            <td>{{item.ctime}}</td>
            <td><a href="#">删除</a></td>
        </tr>
    </table>
</div>

</body>

<script>
    var vm = new Vue({
        el: '#app',
        data: {
            list: [{id: 1, name: '奔驰', ctime: new Date}, {id: 2, name: '大众', ctime: new Date}],
            //用户添加的数据
            formData: {
                id: 0,
                name: ""
            }
        },

        methods: {
            addData: function () {
                //将数据追加到list中
                var p = {id: this.formData.id, name: this.formData.name, ctime: new Date()};
                this.list.push(p);

                //清空页面上的文本框中的数据
                this.formData.id = 0;
                this.formData.name = '';
            }
        }
    });

</script>

</html>
```

### [#](https://web.qianguyihao.com/12-Vue基础/05-Vue的举例：列表功能.html#步骤-4-item的删除)步骤 4：item的删除

html部分：

```html
       <!--绑定delete事件，根据括号里的参数进行删除-->
            <td><a href="#" v-on:click="delData(item.id)">删除</a></td>
```

js部分：

```javascript
    delData: function (id) {
                // 0 提醒用户是否要删除数据
                if (!confirm('是否要删除数据?')) {
                    //当用户点击的取消按钮的时候，应该阻断这个方法中的后面代码的继续执行
                    return;
                }

                // 1 调用list.findIndex()方法根据传入的id获取到这个要删除数据的索引值（在数组中的索引值）
                var index = this.list.findIndex(function (item) {
                    return item.id == id
                });

                // 2.0 调用方法：list.splice(待删除的索引, 删除的元素个数)
                this.list.splice(index, 1);
            }
```

代码解释：`find()`和`findIndex()`是ES6中为数组新增的函数。详细解释如下：

```javascript
    // 根据id得到下标

    // 默认去遍历list集合，将集合中的每个元素传入到function的item里，
    var index = this.list.findIndex(function(item){
    //根据item中的id属性去匹配传进来的id
    //如果是则返回true ；否返回false,继续下面的一条数据的遍历，以此类推
    return item.id ==id; //如果返回true，那么findIndex方法会将这个item对应的index
    });
```

也就是说，我们是根据 item.id 找到这个 item 是属于list 数组中的哪个index索引。找到了index，就可以根据index来删除数组中的那个元素了。

当item被删除后，v-for会被自动调用，进而自动更新view。

完整版代码：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .table {
            width: 800px;
            margin: 20px auto;
            border-collapse: collapse;  /*这一行，不能少：表格的两边框合并为一条*/
        }

        .table th {
            background: #0094ff;
            color: white;
            font-size: 16px;
            border: 1px solid black;
            padding: 5px;
        }

        .table tr td {
            text-align: center;
            font-size: 16px;
            padding: 5px;
            border: 1px solid black;
        }

        .form {
            width: 800px;
            margin: 20px auto;
        }

        .form button {
            margin-left: 10px;
        }
    </style>

    <script src="vue2.5.16.js"></script>
</head>

<body>

    <div id="app">

        <div class="form">

            编号：
            <input type="text" v-model="formData.id"> 名称：
            <input type="text" v-model="formData.name">

            <button v-on:click="addData">添加</button>
        </div>

        <table class="table">
            <th>编号</th>
            <th>名称</th>
            <th>创建时间</th>
            <th>操作</th>
            <tr v-show="list.length == 0">
                <td colspan="4">列表无数据</td>
            </tr>
            <tr v-for="item in list">
                <td>{{item.id}}</td>
                <td>{{item.name}}</td>
                <td>{{item.ctime}}</td>
                <!--绑定delete事件，根据括号里的参数进行删除-->
                <td>
                    <a href="#" v-on:click="delData(item.id)">删除</a>
                </td>
            </tr>
        </table>
    </div>

</body>

<script>
    var vm = new Vue({
        el: '#app',
        data: {
            list: [{ id: 1, name: '奔驰', ctime: new Date }, { id: 2, name: '大众', ctime: new Date }],
            //用户添加的数据
            formData: {
                id: 0,
                name: ""
            }
        },

        methods: {
            addData: function () {
                //将数据追加到list中
                var p = { id: this.formData.id, name: this.formData.name, ctime: new Date() };
                this.list.push(p);

                //清空页面上的文本框中的数据
                this.formData.id = 0;
                this.formData.name = '';
            },  //注意：方法之间用逗号隔开，这个逗号不要忘记了

            delData: function (id) {
                // 0 提醒用户是否要删除数据
                if (!confirm('是否要删除数据?')) {
                    //当用户点击的取消按钮的时候，应该阻断这个方法中的后面代码的继续执行
                    return;
                }

                // 1 调用list.findIndex()方法根据传入的id获取到这个要删除数据的索引值
                var index = this.list.findIndex(function (item) {
                    return item.id == id
                });

                // 2 调用方法：list.splice(待删除的索引, 删除的元素个数)
                this.list.splice(index, 1);
            }


        }
    });

</script>

</html>
```

### 步骤 5：按条件筛选item

现在要求实现的效果是，在搜索框输入关键字 keywords，列表中仅显示匹配出来的内容。也就是说：

- 之前， v-for 中的数据，都是直接从 data 上的list中直接渲染过来的。
- 现在， 我们在使用`v-for`进行遍历显示的时候，不能再遍历全部的 list 了；我们要自定义一个 search 方法，同时，把keywords作为参数，传递给 search 方法。即`v-for="item in search(keywords)"`。

在 search(keywords) 方法中，为了获取 list 数组中匹配的item，我们可以有两种方式实现。如下。

**方式一**：采用`forEach + indexOf()`

```javascript
    search(keywords) { // 根据关键字，进行数据的搜索，返回匹配的item

        //实现方式一：通过 indexOf() 进行匹配。
        var newList = [];
        this.list.forEach(item => {
            if (item.name.indexOf(keywords) != -1) {  //只要不等于 -1，就代表匹配到了
                newList.push(item)
            }
        })
        return newList
    }
```

上方代码中， 我们要注意 indexOf(str) 的用法。举例如下：

```javascript
        var str = 'smyhvae';

        console.log(str.indexOf('s'));  //打印结果：0

        console.log(str.indexOf(''));   //打印结果：0。（说明，即使去匹配空字符串，也是返回0）

        console.log(str.indexOf('h'));  //打印结果：3

        console.log(str.indexOf('x'));  //打印结果：-1 （说明，匹配不到任何字符串）
```

上方代码中，也就是说，如果参数为空字符串，那么，每个item都能匹配到。

**方式二**： filter + includes()方法

```javascript
    search(keywords) { // 根据关键字，进行数据的搜索，返回匹配的item

        var newList = this.list.filter(item => {
            // 注意 ： ES6中，为字符串提供了一个新方法，叫做  String.prototype.includes('要包含的字符串')
            //  如果包含，则返回 true ，否则返回 false
            if (item.name.includes(keywords)) {
                return item
            }
        })

        return newList
    }
```

注意：forEach some filter findIndex，这些都属于数组的新方法，都会对数组中的每一项，进行遍历，执行相关的操作。这里我们采用数组中的 filter 方法，

总的来说，方式二的写法更优雅，因为字符串的 includes()方法确实很实用。

完整版代码如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .table {
            width: 800px;
            margin: 20px auto;
            border-collapse: collapse;/*这一行，不能少：表格的两边框合并为一条*/
        }

        .table th {
            background: #0094ff;
            color: white;
            font-size: 16px;
            border: 1px solid black;
            padding: 5px;
        }

        .table tr td {
            text-align: center;
            font-size: 16px;
            padding: 5px;
            border: 1px solid black;
        }

        .form {
            width: 800px;
            margin: 20px auto;
        }

        .form button {
            margin-left: 10px;
        }
    </style>

    <script src="vue2.5.16.js"></script>
</head>

<body>

    <div id="app">

        <div class="form">

            编号：
            <input type="text" v-model="formData.id"> 名称：
            <input type="text" v-model="formData.name">

            <button v-on:click="addData">添加</button>
            搜索：
            <input type="text" v-model="keywords">

        </div>

        <table class="table">
            <th>编号</th>
            <th>名称</th>
            <th>创建时间</th>
            <th>操作</th>
            <tr v-show="list.length == 0">
                <td colspan="4">列表无数据</td>
            </tr>
            <tr v-for="item in search(keywords)">
                <td>{{item.id}}</td>
                <td>{{item.name}}</td>
                <td>{{item.ctime}}</td>
                <!--绑定delete事件，根据括号里的参数进行删除-->
                <td>
                    <a href="#" v-on:click="delData(item.id)">删除</a>
                </td>
            </tr>
        </table>
    </div>

</body>

<script>
    var vm = new Vue({
        el: '#app',
        data: {
            list: [{ id: 1, name: '奔驰', ctime: new Date }, { id: 2, name: '大众', ctime: new Date }],
            //用户添加的数据
            formData: {
                id: '',
                name: ""
            },
            keywords: ""
        },

        methods: {
            addData: function () {
                //将数据追加到list中
                var p = { id: this.formData.id, name: this.formData.name, ctime: new Date() };
                this.list.push(p);

                //清空页面上的文本框中的数据
                this.formData.id = '';
                this.formData.name = '';
            },  //注意：方法之间用逗号隔开，这个逗号不要忘记了

            delData: function (id) {
                // 0 提醒用户是否要删除数据
                if (!confirm('是否要删除数据?')) {
                    //当用户点击的取消按钮的时候，应该阻断这个方法中的后面代码的继续执行
                    return;
                }

                // 1 调用list.findIndex()方法根据传入的id获取到这个要删除数据的索引值
                var index = this.list.findIndex(function (item) {
                    return item.id == id
                });

                // 2 调用方法：list.splice(待删除的索引, 删除的元素个数)
                this.list.splice(index, 1);
            },

            search(keywords) { // 根据关键字，进行数据的搜索，返回匹配的item

                var newList = this.list.filter(item => {
                    // 注意 ： ES6中，为字符串提供了一个新方法，叫做  String.prototype.includes('要包含的字符串')
                    //  如果包含，则返回 true ，否则返回 false
                    if (item.name.includes(keywords)) {
                        return item
                    }
                })

                return newList
            }
        }
    });

</script>

</html>
```

# 06-自定义过滤器：时间格式化举例

### 过滤器的概念

**概念**：Vue.js 允许我们自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache **插值表达式**、 **v-bind表达式**。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示。

### Vue1.X中的系统过滤器

Vue提供了一系列的固定逻辑来使程序员更加容易的实现这些功能，这些过滤器称之为系统过滤器。

系统过滤器是Vue1.0中存在的，在Vue2.0中已经删除了。

系统过滤器的使用，可以参考参考文档：[http://v1-cn.vuejs.org/api/#过滤器(opens new window)](http://v1-cn.vuejs.org/api/#过滤器)

Vue也提供了一个接口用来供程序员定义属于自己的特殊逻辑，Vue称之为自定义过滤器。我们接下来讲一讲。

## 自定义全局过滤器

### 全局过滤器的基本使用

我们可以用全局方法`Vue.filter()`自定义一个全局过滤器。这样的话，每一个Vue的对象实例（每一个VM实例）都可以拿到这个过滤器。它接收两个参数：过滤器的名称 、过滤器函数。

比如说，我要将`曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人`这句 msg 中的“单纯”改为“邪恶”。可以这样做：

（1）在插值表达式中这样调用：

```html
        <p>{{ msg | msgFormat }</p>
```

上方代码的意思是说：

- **管道符前面**的`msg`：要把 `msg` 这段文本进行过滤，
- **管道符后面**的`msgFormat`：是通过`msgFormat`这个过滤器进行来操作。

（2）定义过滤器`msgFormat`：

```javascript
        // Vue.filter 中的第一个参数是过滤器的名称，第二个参数是具体的过滤器函数
        // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat
        Vue.filter('msgFormat', function (myMsg) {  // function 的第一个参数指的是管道符前面的 msg
            // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则
            return myMsg.replace(/单纯/g, '邪恶')
        })
```

上方代码解释：

- `Vue.filter(‘过滤器的名称’, 具体的过滤器函数)`中的第一个参数指的就是过滤器的名称（必须和**管道符后面**的名称**完全一致**），第二个参数是具体的过滤器函数
- 过滤器函数function中，第一个参数指的**管道符前面的**msg。
- `replace()`方法是用来做字符串的替换的。第一个参数如果只写成`单纯`，那么就会只修改 msg 中的第一个`单纯`字样。所以这里就用正则去匹配msg 中所有的`单纯`字样。

最终，完整版代码如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <div id="app">
        <!-- 通过 过滤器 msgFormat 对 msg 进行过滤-->
        <p>{{ msg | msgFormat }}</p>
    </div>

    <script>
        // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat
        Vue.filter('msgFormat', function (myMsg) {
            // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则
            //将 myMsg 中的所有`单纯`字样，修改为`邪恶`
            return myMsg.replace(/单纯/g, '邪恶')
        })

        // 创建 Vue 实例，得到 ViewModel
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人'
            },
            methods: {}
        });
    </script>
</body>

</html>
```

网页显示效果如下：

![img](assets/20180522_1240.png)

### 给过滤器添加多个参数

上面的举例代码中，``中，**过滤器的调用并没有加参数**，其实它还可以添加多个参数。

接下来，我们在上面的举例代码中进行改进。

**改进一**：过滤器加一个参数。如下：

将 msg 这个字符串中的“单纯”改为 xxx 变量。代码如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <div id="app">
        <!-- 【重要】通过 过滤器 msgFormat 对 msg 进行过滤。括号里的参数代表 function中的 arg2-->
        <p>{{ msg | msgFormat('xxx') }}</p>

    </div>

    <script>
        // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat
        Vue.filter('msgFormat', function (myMsg, arg2) {
            // 字符串的  replace 方法：第一个参数，除了可写一个 字符串之外，还可以定义一个正则；第二个参数代表要替换为上面的xxx
            //将 myMsg 中的所有`单纯`字样，修改为 arg2
            return myMsg.replace(/单纯/g, arg2)
        })

        // 创建 Vue 实例，得到 ViewModel
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人'
            },
            methods: {}
        });
    </script>
</body>

</html>
```

![img](assets/20180525_2135.png)

注意代码中那行重要的注释：括号里的参数代表 function中的 arg2。

**改进二**：过滤器加两个参数。如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <div id="app">
        <!-- 通过 过滤器 msgFormat 对 msg 进行过滤-->
        <!-- 【重要】括号里的第一个参数代表 function 中的 arg2，括号里的第二个参数代表 function 中的 arg3-->
        <p>{{ msg | msgFormat('【牛x】', '【参数arg3】') }}</p>

    </div>

    <script>
        // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat
        Vue.filter('msgFormat', function (myMsg, arg2, arg3) {
            // 字符串的  replace 方法：第一个参数，除了可写一个 字符串之外，还可以定义一个正则；第二个参数代表要替换为 xxx
            //将 myMsg 中的所有`单纯`字样，修改为`arg2 + arg3`
            return myMsg.replace(/单纯/g, arg2 + arg3)
        })

        // 创建 Vue 实例，得到 ViewModel
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人'
            },
            methods: {}
        });
    </script>
</body>

</html>
```

效果如下：

![img](assets/20180525_2150.png)

**改进3：同时使用多个过滤器**

对 msg 同时使用多个过滤器。例如：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <div id="app">
        <!-- 通过 两个过滤器（msgFormat、myFilter2）对 msg 进行过滤-->
        <!-- 将 msg 交给第一个过滤器来处理，然后将处理的结果交给第二个过滤器来处理-->
        <p>{{ msg | msgFormat('【牛x】', '【参数arg3】') | myFilter2}}</p>

    </div>

    <script>
        // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat
        Vue.filter('msgFormat', function (myMsg, arg2, arg3) {
            // 字符串的  replace 方法：第一个参数，除了可写一个 字符串之外，还可以定义一个正则；第二个参数代表要替换为 xxx
            //将 myMsg 中的所有`单纯`字样，修改为`arg2 + arg3`
            return myMsg.replace(/单纯/g, arg2 + arg3)
        })

        //定义第二个全局过滤器
        Vue.filter('myFilter2', function (myMsg) {
            //在字符串 msg 的最后面加上【后缀】
            return myMsg + '【后缀】'
        })

        // 创建 Vue 实例，得到 ViewModel
        var vm = new Vue({
            el: '#app',
            data: {
                msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人'
            },
            methods: {}
        });
    </script>
</body>

</html>
```

效果如下：

![img](assets/20180525_2200.png)

上方代码中，添加了多个过滤器，实现的思路是：**将 msg 交给第一个过滤器来处理，然后将处理的结果交给第二个过滤器来处理** 。

### [#](https://web.qianguyihao.com/12-Vue基础/06-自定义过滤器：时间格式化举例.html#举例1-时间格式化)举例1：时间格式化

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <div id="app">
        {{ time }}
        <br /> {{ time | datefmt }}
    </div>

    <div id="app1">
        {{ time | datefmt }}
    </div>
</body>
<script>

    // 定义一个名称为 datafmt的全局过滤器
    Vue.filter('datefmt', function (input) {
        // 过滤器的逻辑：将input的值格式化成 yyyy-MM-dd 字符串输出
        var res = '';
        var year = input.getFullYear();
        var month = input.getMonth() + 1;
        var day = input.getDate();

        res = year + '-' + month + '-' + day;

        return res;
    });

    new Vue({
        el: '#app1',
        data: {
            time: new Date()
        }
    })

    new Vue({
        el: '#app',
        data: {
            time: new Date()
        }
    });
</script>

</html>
```

运行效果：

![img](assets/20180525_2230.png)

### [#](https://web.qianguyihao.com/12-Vue基础/06-自定义过滤器：时间格式化举例.html#举例2-时间格式化)举例2：时间格式化

上面的举例1，时间格式化的过滤器，我们还有个更高端的写法：（字符串模板）

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <div id="app">
        2018-05-25T14:06:51.618Z
        <br /> {{ '2018-05-25T14:06:51.618Z' | dateFormat }}
    </div>

</body>
<script>

    Vue.filter('dateFormat', function (dateStr, pattern = "") {
        // 根据给定的时间字符串，得到特定的时间
        var dt = new Date(dateStr)

        //   yyyy-mm-dd
        var y = dt.getFullYear()
        var m = dt.getMonth() + 1
        var d = dt.getDate()

        // return y + '-' + m + '-' + d

        if (pattern.toLowerCase() === 'yyyy-mm-dd') { //如果调用过滤器的参数写的是 yyyy-mm-dd，那就按照这种  yyyy-mm-dd 的格式写
            //这里用的是字符串模板
            return `${y}-${m}-${d}`
        } else {  //否则（比如说调用过滤器时不写参数），后面就补上 时-分-秒
            var hh = dt.getHours()
            var mm = dt.getMinutes()
            var ss = dt.getSeconds()

            return `${y}-${m}-${d} ${hh}:${mm}:${ss}`
        }
    })

    new Vue({
        el: '#app',
        data: {
            time: new Date()
        }
    });
</script>

</html>
```

运行结果：![img](assets/20180526_2319.png)

【荐】**举例2的改进**：（字符串的padStart方法使用）

上图中，我们可以看到，箭头处的时间有些问题，比如说，`6`要写成`06`更合适。为了实现这个功能，我们可以这样做：

使用ES6中的字符串新方法 `String.prototype.padStart(maxLength, fillString='')` 或 `String.prototype.padEnd(maxLength, fillString='')`来填充字符串。 `pad`在英文中指的是`补充`。

实现举例如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <div id="app">
        2018-05-25T14:06:51.618Z
        <br /> {{ '2018-05-25T14:06:51.618Z' | dateFormat }}
    </div>

</body>
<script>

    Vue.filter('dateFormat', function (dateStr, pattern) {
        // 根据给定的时间字符串，得到特定的时间
        var dt = new Date(dateStr)

        //   yyyy-mm-dd
        var y = dt.getFullYear()
        var m = (dt.getMonth() + 1).toString().padStart(2, '0')
        var d = dt.getDate().toString().padStart(2, '0')

        if (pattern && pattern.toLowerCase() === 'yyyy-mm-dd') { //如果调用过滤器的参数写的是 yyyy-mm-dd，那就按照这种  yyyy-mm-dd 的格式写
            //这里用的是字符串模板
            return `${y}-${m}-${d}`
        } else { //否则（比如说调用过滤器时不写参数），后面就补上 时-分-秒
            var hh = dt.getHours().toString().padStart(2, '0')
            var mm = dt.getMinutes().toString().padStart(2, '0')
            var ss = dt.getSeconds().toString().padStart(2, '0')

            return `${y}-${m}-${d} ${hh}:${mm}:${ss} ~~~~~~~`
        }
    })

    new Vue({
        el: '#app',
        data: {
            time: new Date()
        }
    });
</script>

</html>
```

运行效果如下：

![img](assets/20180526_2323.png)

`pattern`参数的解释：

在做`if (pattern && pattern.toLowerCase() === 'yyyy-mm-dd')`这个判断时，逻辑是：**先保证pattern参数传进来了，然后继续后面的判断**。

我们不能写成：`if (pattern.toLowerCase() === 'yyyy-mm-dd')`。因为，万一在调用的时候，不传递参数pattern，那么 if语句就相当于`if (undefined.toLowerCase() === 'yyyy-mm-dd')`，就会报错。

当然，ES6中有个新特性叫“默认参数”，我们就可以这样写：

```html
!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <div id="app">
        2018-05-25T14:06:51.618Z
        <br /> {{ '2018-05-25T14:06:51.618Z' | dateFormat }}
    </div>

</body>
<script>

    Vue.filter('dateFormat', function (dateStr, pattern = '') {
        // 根据给定的时间字符串，得到特定的时间
        var dt = new Date(dateStr)

        //   yyyy-mm-dd
        var y = dt.getFullYear()
        var m = (dt.getMonth() + 1).toString().padStart(2, '0')
        var d = dt.getDate().toString().padStart(2, '0')

        if (pattern.toLowerCase() === 'yyyy-mm-dd') { //如果调用过滤器的参数写的是 yyyy-mm-dd，那就按照这种  yyyy-mm-dd 的格式写
            //这里用的是字符串模板
            return `${y}-${m}-${d}`
        } else { //否则（比如说调用过滤器时不写参数），后面就补上 时-分-秒
            var hh = dt.getHours().toString().padStart(2, '0')
            var mm = dt.getMinutes().toString().padStart(2, '0')
            var ss = dt.getSeconds().toString().padStart(2, '0')

            return `${y}-${m}-${d} ${hh}:${mm}:${ss} ~~~~~~~`
        }
    })

    new Vue({
        el: '#app',
        data: {
            time: new Date()
        }
    });
</script>

</html>
```

## 自定义私有过滤器

**私有过滤器**：在某一个 vue 对象内部定义的过滤器称之为私有过滤器。这种过滤器只有在当前vue对象的el指定的监管区域有用。

**举例**：日期格式化

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <div id="app">
        {{ time }}
        <br />
        {{ time | datefmt }}
    </div>

</body>
<script>

    new Vue({
        el: '#app',
        data: {
            time: new Date()
        },
        //在某一个vue对象内部定义的过滤器称之为私有过滤器，
        //这种过滤器只有在当前vue对象el指定的监管的区域有用
        filters: {
            // input是自定义过滤器的默认参数，input的值永远都是取自于 | 左边的内容
            datefmt: function (input) {
                // 定义过滤器的内容：将input的值格式化成 yyyy-MM-dd 字符串输出
                var res = '';
                var year = input.getFullYear();
                var month = input.getMonth() + 1;
                var day = input.getDate();

                res = year + '-' + month + '-' + day;

                return res;
            }
        }
    });
</script>

</html>
```

上面的代码中，我们在vue实例中，通过`filters`关键字，在里面定义了一个局部过滤器`datefmt`。

运行结果：

![img](assets/20180405_2038.png)

第一行代码显示的是默认的date。第二行代码显示的是格式化之后的date，说明过滤器是起到了作用的。

### [#](https://web.qianguyihao.com/12-Vue基础/06-自定义过滤器：时间格式化举例.html#总结)总结

过滤器调用的时候，采用的是**就近原则**，如果私有过滤器和全局过滤器名称一致了，这时候 优先调用私有过滤器。

# 07-自定义按键修饰符&自定义指令

## v-on的按键修饰符

### [#](https://web.qianguyihao.com/12-Vue基础/07-自定义按键修饰符&自定义指令.html#vue-内置的按键修饰符)Vue 内置的按键修饰符

通俗一点讲，指的是：监听键盘输入的事件。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符。如下：

Vue内置的按键修饰符：

```text
   .enter
    .tab
    .delete (捕获 “删除” 和 “退格” 键)
    .esc
    .space
    .up
    .down
    .left
    .right
    1.0.8+版本：支持单字母的按键别名。
```

比如说，`keyup`指的是：键盘（任何键位）抬起时的监听事件。`.enter`指的是：按enter键的按键修饰符。我们把这两个结合起来看看。

**`@keyup.enter`举例**：按enter键后的监听事件

`@keyup.enter="addData"`表示：按住enter键后，执行addData()方法。**全称**是`v-on:key.enter="addData"`。

我们还是拿`01-04`这篇文章中的列表功能来举例。之前是点击“添加”按钮后，列表中会添加一个item。现在要求：在**输入框**中按enter键后，也能添加一个item。

核心代码如下：

```html
	<input type="text" v-model="formData.name" @keyup.enter="addData">
```

注意，如果写成`@keyup="addData"`，效果却是：只要键盘的任何键位打了字（还没来得及按enter键），就会执行addData()方法，这种效果显然不是我们想要的。所以要加上修饰符`.enter`，表示只针对enter键。

### 自定义的按键修饰符

如果我们直接在代码的`<input>`标签里写`@keyup.f2="addData"`，那么，按住「F2键」后，是没有效果的，因为「F2键」不是内置的按键修饰符（如果F2不能验证，你可以试一下F7）。

我们知道，每个按键都有一个键盘码。参考链接：

- [js 里面的键盘事件对应的键码(opens new window)](http://www.cnblogs.com/wuhua1/p/6686237.html)

通过查阅，我们知道了「F2键」的键盘码为`113`，那代码可以这样写：（按住F2键后，执行 addData 方法）

```html
	<input type="text" v-model="formData.name" @keyup.113="addData">
```

虽然键盘码很全，但是不好记呀。于是，接下来，我们给键盘码定义别名。

**自定义全局按键修饰符**：

```text
    //自定义全局按键修饰符
    Vue.config.keyCodes.f2 = 113;
```

上方代码的书写位置，与自定义全局过滤器的位置，是并列的。

然后，我们就可以使用键盘码的别名了。

## 自定义全局指令

### [#](https://web.qianguyihao.com/12-Vue基础/07-自定义按键修饰符&自定义指令.html#自定义全局指令的举例1)自定义全局指令的举例1

**举例1**：让指定文本框自动获取焦点

如果我们想实现这个例子，原生js的写法是：

```javascript
    //原生js写法：网页一打开，就让指定的输入框自动获取焦点
    document.getElementById('search').focus()
```

代码的位置：

![img](assets/20180527_2340.png)

但我们不建议这样做。我们可以通过Vue中的自定义指令来实现这个例子。步骤如下。

（1）使用`Vue.directive()`自定义全局指令：

```javascript
    //自定义全局指令 v-focus：让文本框自动获取焦点
    //参数1：指令的名称。注意，在定义的时候，指令的名称前面，不需要加 v- 前缀；但是：在`调用`的时候，必须在指令名称前 加上 v- 前缀
    //参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作
    Vue.directive('focus', {
    	//在每个函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象（DOM对象）
        bind: function (el) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】
            // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用
            //  因为，一个元素，只有插入DOM之后，才能获取焦点
            // el.focus()
        },
        inserted: function (el) {  // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】
            el.focus()
            // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效
        },
        updated: function (el) {  // 当VNode更新的时候，会执行 updated， 【可能会触发多次】

        }
    })
```

上方的代码中，如果我们把`el.focus()`这行代码写在`bind`方法里，是没有效果的（但不会报错）。没有效果是因为，在执行到`bind`方法的时候，元素还没有插入到dom中去。

由此可以看看出：`bind`、`inserted`、`updated`这三个钩子函数的执行时机不同，且执行的次数有区别。

（2）在指定的文本框上加``：

```html
<input type="text" id="search" v-model="keywords" v-focus>
```

完整版代码如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>

    <div id="app">
        搜索框：
        <input type="text" id="search" v-model="name" v-focus>
    </div>

    <script>

        //自定义全局指令 v-focus，让文本框自动获取焦点
        //参数1：指令的名称。注意，在定义的时候，指令的名称前面，不需要加 v- 前缀；但是：在`调用`的时候，必须在指令名称前 加上 v- 前缀
        //参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作
        Vue.directive('focus', {
            //在每个函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象（DOM对象）
            bind: function (el) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】
                // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用
                //  因为，一个元素，只有插入DOM之后，才能获取焦点
                // el.focus()
            },
            inserted: function (el) {  // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】
                el.focus()
                // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效
            },
            updated: function (el) {  // 当VNode更新的时候，会执行 updated， 【可能会触发多次】
            }
        })

        new Vue({
            el: '#app',
            data: {
                name: 'smyhvae'
            }
        })
    </script>
</body>

</html>
```

### 自定义全局指令：使用钩子函数的第二个binding参数拿到传递的值

**举例2**：设置DOM元素的color样式

参考举例1中的写法，我们可能会这样给DOM元素设置样式：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>

    <div id="app">
        搜索框：
        <input type="text" id="search" v-model="name" v-color>
    </div>

    <script>

        //自定义全局指令 v-color：设置DOM元素的color属性
        Vue.directive('color', {
            bind: function (el) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】
                el.style.color = 'red';
            },
            inserted: function (el) {  // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】
                // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效
                //el.focus()
            },
            updated: function (el) {  // 当VNode更新的时候，会执行 updated， 【可能会触发多次】
            }
        })

        new Vue({
            el: '#app',
            data: {
                name: ''
            }
        })
    </script>
</body>

</html>
```

如上方代码所示，我们自定义了一个指令`v-color`，然后在`input`标签中用上了这个指令，就给元素设置了color属性。但是这个代码有个弊端是：color的属性值在定义指令的时候，被写死了。如何完善呢？我们可以在DOM元素中传参。一起来看看。

代码如下：【荐】

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>

    <div id="app">
        搜索框1：
        <input type="text" id="search" v-model="name" v-color="'green'">
    </div>

    <script>

        //自定义全局指令 v-color：设置DOM元素的color属性
        Vue.directive('color', {
            // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式
            // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素
            // 意思是说，我们可以把样式的代码写到bind中去（即使这个时候，dom元素还没有被创建）
            bind: function (el, binding) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】

                console.log(binding.name); //打印结果：color
                console.log(binding.value); //打印结果：green
                console.log(binding.expression);  //'green'

                el.style.color = binding.value// 通过bining拿到v-color中传递过来的值

            },
            inserted: function (el) {  // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】
                // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效
                //el.focus()
            },
            updated: function (el) {  // 当VNode更新的时候，会执行 updated， 【可能会触发多次】
            }
        })

        new Vue({
            el: '#app',
            data: {
                name: 'smyhvae'
            }
        })
    </script>
</body>

</html>
```


上方代码中,bind方法里传递的第二个参数`binding`，可以拿到DOM元素中`v-color`里填的值。注意，`v-color="'green'"`，这里面写的是字符串常量；如果去掉单引号，就成了变量，不是我们想要的。

效果：

![img](assets/20180610_1323.png)

**自定义全局指令的简写形式**：

在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如上面的代码中，我们可以写成简写形式：

```javascript
        Vue.directive('color', function (el, binding) { //注意，这个function等同于把代码写到了 bind 和 update 中去
            el.style.color = binding.value
        })
```

## 自定义私有指令

**自定义私有指令**：在某一个 vue 对象内部自定义的指令称之为私有指令。这种指令只有在当前vue对象的el指定的监管区域有用。

代码举例：（设置文字的font-weight属性）

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>

    <div id="app">
        <span v-fontweight="600">生命壹号</span>
    </div>
    <script>

        new Vue({
            el: '#app',
            data: {
                name: 'smyhvae'
            },
            //自定义私有指令
            directives: {
                'fontweight': {
                    bind: function (el, binding) {
                        el.style.fontWeight = binding.value;
                    }
                }
            }
        })
    </script>
</body>

</html>
```

效果：

![img](assets/20180610_1400.png)

注意， el.style.fontWeight设置属性值，至少要600，否则看不到加粗的效果。

**自定义私有指令的简写形式**：

在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如上面的代码中，我们可以写成简写形式：

```text
            //自定义私有指令（简写形式）
            directives: {
                'fontweight': function (el, binding) { //注意，这个function等同于把代码写到了 bind 和 update 中去
                    el.style.fontWeight = binding.value;
                }
            }
```

# 08-Vue实例的生命周期函数

## 介绍

- [vue实例的生命周期 (opens new window)](https://cn.vuejs.org/v2/guide/instance.html#实例生命周期)：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期。
- [生命周期钩子 (opens new window)](https://cn.vuejs.org/v2/api/#选项-生命周期钩子)：就是生命周期事件的别名而已。

生命周期钩子 = 生命周期函数 = 生命周期事件。

## [#](https://web.qianguyihao.com/12-Vue基础/08-Vue实例的生命周期函数.html#生命周期函数的主要分类)生命周期函数的主要分类

![img](assets/20180422_1650.png)

根据上面这张图，我们把生命周期函数主要分为三类。

### [#](https://web.qianguyihao.com/12-Vue基础/08-Vue实例的生命周期函数.html#_1、创建期间的生命周期函数)1、创建期间的生命周期函数

- beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性
- created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板。我们可以在这里进行Ajax请求。
- beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中
- mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示。（mounted之后，表示**真实DOM渲染完了，可以操作DOM了**）

**举例**：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <!--这个div区域就是MVVM中的 View-->
    <div id="app">
    </div>
</body>

<script>
    new Vue({
        el: '#app',
        data: {
            msg: 'hello vuejs'
        },
        // 这是第1个生命周期函数，表示实例完全被创建出来之前，会执行它
        beforeCreate: function () {
            console.log('01 beforeCreate', this.msg);
            //注意：在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化
        },

        // 这是第2个生命周期函数
        created: function () {
            console.log('02 created', this.msg);
            //注意：如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作
        },

        // 这是第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中
        beforeMount: function () {
            console.log('03 beforeMount', this.msg);
            // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串
        },

        // 这是第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了
        mounted: function () {
            console.log('04 mounted', this.msg);
            // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了
            // 此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动
        }
    });

</script>

</html>
```

打印结果：

![img](assets/20180610_1500.png)

### [#](https://web.qianguyihao.com/12-Vue基础/08-Vue实例的生命周期函数.html#运行期间的生命周期函数)运行期间的生命周期函数

- beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点
- updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了。

PS：数据发生变化时，会触发这两个方法。不过，我们一般用watch来做。

**举例**：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="vue2.5.16.js"></script>
</head>

<body>
    <!--这个div区域就是MVVM中的 View-->
    <div id="app">
        <input type="button" value="修改flag" @click="myMethod">
        <h3 id="h3">{{ flag }}</h3>
    </div>
</body>

<script>
    new Vue({
        el: '#app',
        data: {
            msg: 'hello vue',
            flag: false
        },

        methods: {
            myMethod: function () {
                this.flag = true;
            }
        },


        // 接下来的是运行中的两个事件
        // 这时候，我们的界面还没有被更新【但是，数据被更新了吗？  数据肯定被更新了】
        beforeUpdate() {
            console.log('-------------05 beforeUpdate', this.msg);

            // 结论：当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步
            console.log('界面上DOM元素显示的内容：' + document.getElementById('h3').innerText)
            console.log('data 中的 msg 数据：' + this.flag)
        },
        updated() {
            console.log('-------------06 updated', this.msg);

            // 结论：updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的
            console.log('界面上DOM元素显示的内容：' + document.getElementById('h3').innerText)
            console.log('data 中的 msg 数据：' + this.flag)
        }
    });

</script>

</html>
```

当我们点击按钮后，运行效果是：

![img](assets/20180610_1528.png)

可以看出：

- 当执行 beforeUpdate 的时候，页面中的显示的数据还是旧的，但此时 data 数据是最新的
- updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的

### [#](https://web.qianguyihao.com/12-Vue基础/08-Vue实例的生命周期函数.html#_3、销毁期间的生命周期函数)3、销毁期间的生命周期函数

- beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。
- destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

PS：可以在beforeDestroy里**清除定时器、或清除事件绑定**。

## [#](https://web.qianguyihao.com/12-Vue基础/08-Vue实例的生命周期函数.html#生命周期函数图解)生命周期函数图解

![img](assets/20180611_2130.png)

PS：图片来自网络。