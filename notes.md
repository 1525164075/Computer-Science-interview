### **学习计划总原则**
1. **交替学习**：每天从两门课程各选1章，保持知识交叉关联。
2. **逻辑顺序**：按章节顺序推进，优先学习基础模块（如网络基础、硬件结构）。
3. **间隔复习**：每学完3-5章后插入复习日，后期每学完一大篇集中复习。
4. **实践与理论结合**：抓包分析、系统命令等实操章节紧跟理论。

---

### **第一阶段：基础篇与核心概念（第1-15天）**
**目标**：掌握网络模型、HTTP协议、CPU与内存管理核心知识。

> | 天数 | 图解网络                              | 图解系统                 | 备注                         |
> | ---- | ------------------------------------- | ------------------------ | ---------------------------- |
> | 1    | 1.1 [TCP/IP网络模型](#1.1-1) | 1.1 [CPU执行程序](#1.1-2) | 从底层模型和硬件开始         |
> | 2    | 1.2 键入网址到网页显示                | 1.2 存储器金字塔         | 理解网络请求与硬件存储联动   |
> | 3    | 1.3 Linux收发网络包                   | 1.3 优化CPU代码          | **复习1.1-1.3（网络+系统）** |
> | 4    | 2.1 HTTP面试题                        | 1.4 CPU缓存一致性        | HTTP基础与硬件性能优化       |
> | 5    | 2.2 HTTP/1.1优化                      | 1.5 CPU执行任务          | **复习1.4-1.5（系统）**      |
> | 6    | 2.3 HTTPS RSA握手                     | 1.6 软中断机制           | 加密协议与系统中断机制       |
> | 7    | 2.4 HTTPS ECDHE握手                   | 1.7 浮点数精度问题       | **复习2.1-2.4（网络）**      |
> | 8    | 2.5 HTTPS优化                         | 2.1 Linux vs Windows内核 | 系统架构对比                 |
> | 9    | 2.6 HTTP/2优势                        | 3.1 虚拟内存原理         | HTTP演进与内存管理核心       |
> | 10   | 2.7 HTTP/3                            | 4.1 进程与线程基础       | **复习3.1+4.1（系统）**      |
> | 11   | 2.8 HTTP vs RPC                       | 4.2 进程间通信（IPC）    | 协议对比与多进程通信         |
> | 12   | 2.9 HTTP vs WebSocket                 | 4.3 多线程同步机制       | **复习2.5-2.9（网络）**      |
> | 13   | **复习1.1-2.9（网络）**               | **复习1.1-4.3（系统）**  | 第一阶段总复习               |
>

---

### **第二阶段：深入协议与系统机制（第16-40天）**
**目标**：掌握TCP/IP、进程调度、网络系统优化。

| 天数 | 图解网络                  | 图解系统                | 备注                     |
| ---- | ------------------------- | ----------------------- | ------------------------ |
| 14   | 3.1 TCP/IP协议栈优化      | 4.4 死锁原理与解决      | 协议优化与并发问题       |
| 15   | 3.2 TCP重传与流量控制     | 4.5 悲观锁 vs 乐观锁    | **复习4.4-4.5（系统）**  |
| 16   | 3.3 TCP抓包分析           | 5.1 进程调度算法        | 实战分析与调度策略       |
| 17   | 3.4 TCP半/全连接队列      | 5.2 页面置换算法        | **复习3.1-3.4（网络）**  |
| 18   | 3.5 优化TCP性能           | 5.3 磁盘调度算法        | 性能调优与存储管理       |
| 19   | 3.6 TCP面向字节流         | 6.1 文件系统            | **复习5.1-5.3（系统）**  |
| 20   | 3.7 TCP初始化序列号       | 7.1 键盘输入处理流程    | 协议细节与I/O机制        |
| 21   | 3.8 SYN报文丢弃场景       | 8.1 Linux收发网络包     | **复习3.5-3.8（网络）**  |
| 22   | 3.9 乱序FIN包处理         | 8.2 零拷贝              | 网络包处理与高性能优化   |
| 23   | 3.10 TIME_WAIT与SYN       | 8.3 select/poll/epoll   | **复习8.1-8.3（系统）**  |
| 24   | 3.11 TCP断电 vs 进程崩溃  | 8.4 Reactor vs Proactor | 连接异常与网络模式对比   |
| 25   | 3.12 拔网线后TCP状态      | 9.1 网络性能指标        | **复习3.9-3.12（网络）** |
| 26   | 3.13 tcp_tw_reuse关闭原因 | 9.2 日志分析PV/UV       | 端口复用与运维监控       |
| 27   | **复习3.1-3.13（网络）**  | **复习8.1-9.2（系统）** | 第二阶段总复习           |

---

### **第三阶段：高级主题与综合应用（第41-60天）**
**目标**：IP协议、系统命令、协议缺陷与可靠传输。

| 天数 | 图解网络                | 图解系统                    | 备注                     |
| ---- | ----------------------- | --------------------------- | ------------------------ |
| 28   | 4.1 IP基础知识          | 10.1 计算机网络学习法       | IP基础与学习方法         |
| 29   | 4.2 Ping工作原理        | 10.2 操作系统学习法         | **复习4.1-4.2（网络）**  |
| 30   | 4.3 断网Ping测试        | 10.3 画图经验               | 网络诊断与知识总结       |
| 31   | 3.14 TLS与TCP同时握手   | **复习4.1-7.1（系统）**     | 协议联动与系统综合复习   |
| 32   | 3.15 Keepalive区别      | **复习8.1-8.4（系统）**     | 长连接机制与网络系统复习 |
| 33   | 3.16 TCP缺陷            | **复习9.1-9.2（系统）**     | 协议不足与运维命令复习   |
| 34   | 3.17 基于UDP的可靠传输  | **复习10.1-10.3（系统）**   | 协议创新与学习心得       |
| 35   | **复习4.1-4.3（网络）** | **综合复习（系统）**        | IP篇与系统全复习         |
| 36   | 3.18 TCP/UDP端口共用    | **实战：抓包分析+性能监控** | 协议冲突与实操演练       |
| 37   | 3.19 无listen的连接     | **实战：死锁调试+页面置换** | 连接异常与系统调试       |
| 38   | 3.20 无accept的连接     | **复习所有重点章节**        | 高级连接机制与综合复习   |
| 39   | 3.21 TCP数据丢失场景    | **复习所有重点章节**        | 协议可靠性复习           |
| 40   | 3.22 四次挥手变三次     | **模拟面试题训练**          | 协议细节与面试准备       |
| 41   | 3.23 序列号与确认号变化 | **模拟面试题训练**          | 最终章学习与面试实战     |
| 42   | **复习所有网络章节**    | **复习所有系统章节**        | 总复习与查漏补缺         |

---

### **关键策略**
1. **每日学习时间**：建议2小时（1小时新知识+1小时复习）。
2. **实操章节**：如TCP抓包（3.3）、零拷贝（8.2）、日志分析（9.2）需动手实践。
3. **复习方法**：用思维导图总结核心机制（如TCP握手、进程调度算法）。

按此计划，60天内可系统掌握网络协议栈与操作系统核心机制，同时通过间隔复习巩固记忆。





#### 2.28 

##### 1.1 TCP/IP网络模型 <a name="1.1-1"></a>

> TCP/IP 模型（全称 Transmission Control Protocol/Internet Protocol，即传输控制协议/互联网协议）是一种网络通信模型，用来描述计算机网络中数据的传输和通信过程。它是互联网的基础，现实中大多数网络协议都基于这个模型构建。

1、为什么要有TCP/IP网络模型？

TCP/IP协议是为了解决计算机之前的通信问题。对于同一种设备上的通讯，可以有多种通信方式，但是在不同设备上的进程间通信，就需要网络通信。而设备时多样性的，要兼容多种设备，就需要协商一套通用的网络协议。

2、TCP/IP协议的层级

分层就是把一个大任务拆成几个小任务，给不同的人去做。

**为什么要把 TCP/IP 分层？**

- 分工明确，降低复杂性
- 各层独立，互不干扰
- 提高灵活性和兼容性
- 方便排查问题
- 复用化和标准化

TCP/IP分成四层：网络接口层、网络层、传输层、应用层

![undefined](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/UDP_encapsulation.svg/1920px-UDP_encapsulation.svg.png)



**应用层**

最上层，用户能直接接触到的就是应用层。负责处理用户能看到的、用到的东西，比如浏览网页、发邮件、看视频。当两个不同的设备的应用需要通信的时候，应用把应用数据传给下一层，也就是传输层。

应用层只需要专注于为用户提供应用功能。应用层的关键协议如下：

- HTTP(超文本传输协议)：输入网址，HTTP负责把网站内容拉回来
- SMTP(简单右键传输协议)：发送邮件
- FTP(文件传输协议)：传文件的协议

应用层不用关心数据如何传输，它是在操作系统中的用户态，传输层及以下则工作在内核态。



**传输层**

应用层的数据包会传给传输层，传输层是为了应用层提供网络支持。

![image-20250227215640454](C:/Users/15251/AppData/Roaming/Typora/typora-user-images/image-20250227215640454.png)

在TCP/IP模型中，传输层主要由两种协议主导：**TCP（传输控制协议）\**和\**UDP（用户数据报协议）**。

 **TCP（Transmission Control Protocol）**：数据包能可靠地传输给对方

- **特点**: 面向连接、可靠的数据传输。
- 功能
  - **建立连接**：通过三次握手确保通信双方准备就绪。
  - **数据可靠性**：提供数据包的排序、重传机制，确保数据无丢失、无重复且按序到达。
  - **流量控制**：通过滑动窗口机制调节发送速率，避免接收方过载。
  - **拥塞控制**：防止网络过载，提升传输效率。
- **应用场景**：适用于需要高可靠性的场景，如网页浏览（HTTP/HTTPS）、电子邮件（SMTP）、文件传输（FTP）。

**UDP（User Datagram Protocol）**：只负责发送数据包，不保证数据包能否抵达对方

- **特点**: 无连接、不可靠的数据传输。
- 功能
  - **简单高效**：不建立连接，直接发送数据，头部开销小。
  - **无序、无保障**：不保证数据到达，也不保证顺序，适合对实时性要求高而可靠性要求不高的场景。
- **应用场景**：常用于实时应用，如视频流（直播）、语音通话（VoIP）、在线游戏，以及DNS查询。

UDP也可以实现可靠传输，把TCP的特性在应用层上实现就可以，不过要实现一个商用的可靠UDP传输协议

>“应用层实现”指的是这些可靠性逻辑被写进了应用程序的代码，而不是依赖操作系统提供的TCP协议栈。

当传输的数据包大小超过了MSS( Maximum Segment Size)，就要把数据包分块，这样即使中途有一个分块丢失或者损坏了，只需要重新发送这个分块，而不是重新发送整个数据包。在TCP协议中，把每个分块称为一个TCP段（TCP Segment）。

![image-20250227220742953](C:/Users/15251/AppData/Roaming/Typora/typora-user-images/image-20250227220742953.png)

当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接受或者传输数据，因此需要一个编号将应用区分开，这个编号就是端口。

>假设你的电脑（IP地址是192.168.1.1）同时在：
>
>用浏览器访问网页（服务器IP是93.184.216.34，端口80）。
>
>用聊天软件收消息（服务器IP是203.0.113.5，端口6667）。
>
>数据包到达时：
>
>一个数据包的目标是“192.168.1.1:54321”（浏览器用的临时端口），操作系统看到54321，知道是浏览器的。
>
>另一个数据包的目标是“192.168.1.1:12345”（聊天软件的端口），操作系统看到12345，知道是聊天软件的。
>
>这里，**54321**和**12345**就是端口号，它们区分了同一台设备上的不同应用。



**网络层**

传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。
也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层

![image-20250227221957121](assets/image-20250227221957121.png)

IP协议（Internet Protocol）：IP协议会将传输层的报文作为数据部分，再加上IP包组装成IP报文，如果IP报文大小超过MTU（最大传输单元）就会再次进行切片，得到一个即将发送到网络的IP报文。

![image-20250227222431587](assets/image-20250227222431587.png)

IP地址的网络号（Network ID）和主机号（Host ID）是IP地址的两个核心组成部分，用于在网络中定位设备。它们是在IP协议（特别是IPv4）中通过子网掩码划分出来的，分别表示“网络”和“主机”的标识。

**网络号（Network ID）**：标识一个设备所在的网络段。所有属于同一网络的设备共享相同的网络号。

**主机号（Host ID）**：标识网络内的具体设备。同一网络中，每个设备的主机号是唯一的。

**路由（Routing）**：指的是数据包从源主机通过网络传输到目标主机的路径选择过程。它由网络层（主要是IP协议）和路由器（Router）共同实现。简单来说，路由就像导航系统，决定数据包在复杂的网络中如何“走”才能到达目的地。路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。

*所以，IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘*



**网络接口层**

网络接口层（Network Interface Layer），也常称为**数据链路层和物理层的组合**，是TCP/IP模型中最底层的一层。它负责将上层（网络层）的IP数据包转化为可以在物理介质上传输的信号，并在接收端将信号还原为数据包。简单来说，网络接口层是网络通信的“硬件与软件交界处”，处理设备与设备之间直接的数据传输。

![image-20250227223147200](assets/image-20250227223147200.png)

IP 头部中的接收方IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。
什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。
以太网在判断网络包目的地时和IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到MAC地址。
MAC头部是以太网使用的头部，它包含了接收方和发送方的MAC地址等信息，我们可以通过ARP协议获取对方的 MAC 地址。



**总结**

![image-20250227223926179](assets/image-20250227223926179.png)

![image-20250227223943538](assets/image-20250227223943538.png)

网络接口层的传输单位是帧(frame)，IP 层的传输单位是包(packet)，TCP 层的传输单位是段(segment)，HTTP的传输单位则是消息或报文(message)。但这些名词并没有什么本质的区分，可以统称为数据包。



##### 1.1 CPU执行程序<a name="1.1-2"></a>

**1.图灵机**

![image-20250228101841864](assets/image-20250228101841864.png)

组成：一条纸袋，一个读写头，读写头上的一些部件（比如存储单元、控制单元以及运算单元）

模拟数学运算$1+2$

（1）用读写通用把1、2、+这三个字符分别写入纸袋的三个格子，然后读写头先停在“1”对应的格子上；

（2）1读入到存储设备，这个存储设备称为图灵机的状态；

（3）读写头向右移动，用同样的方式把“2”读入到图灵机的状态；

（4）再向右移动，碰到"+"，将“+”号传输给控制单元，控制单元会发现是一个”+”而不是数字，所以没有像数字存入到状态中，而是作为运算单元，把“1”和“2”读入并且计算，再将计算的结果3存放到状态中；

（5）运算单元把结果返回给控制单元，控制单元将结果传输给读写头，读写头向右移动，把3写入纸袋的格子里面；

**2.冯诺依曼模型**

组成部分：中央处理器（CPU）、内存、输入设备、输出设备、总线。

![image-20250228112008827](assets/image-20250228112008827.png)

（1）内存

程序和数据都是存储在内存，存储的区域是线性的。

内存的地址是从0开始编号的，然后自增排列，最好一个地址为内存总字节数-1，这种结构类似数组这种数据结构。由于是线性排列的，所以内存读写任何一个数据的速度都是一样的。

（2）CPU（中央处理器）

CPU的位宽：

- 32位：一次可以计算32b，4个字节，一次最大可以计算2³² - 1 = 4,294,967,295（无符号整数）
- 64位：一次可以计算64b，8个字节，一次最大可以计算2⁶⁴ - 1 = 18,446,744,073,709,551,615（无符号整数）

CPU内部还有组件，常见的如

- 寄存器：存储计算时的数据

> 相比于内存而言，寄存器的计算速度更快，因为内存离CPU太远了，而寄存器就在CPU内，还紧挨着控制单元和逻辑运算单元。

通用寄存器：用来存放需要计算的数据，比如两个加数

程序计数器：存储CPU要执行的下一条指令

指令寄存器：存放指令

- 控制单元：负责控制CPU工作
- 逻辑运算单元等：负责运算

（3）总线

- 地址总线：用于指定CPU将要操作的内存地址
- 数据总线：用于读写内存的数据
- 控制总线：用于发送和接受信号，当CPU收到信号后也需要控制总线

CPU需要读写内存数据的时候，需要两个总线：首先通过地址总线来指定内存的地址；再通过数据总线来传输数据

（4）输入、输出设备

输入设备向计算机输入数据，计算机通过计算后，把数据输出给输出设备。

**3.线路位宽与CPU位宽**

**线路位宽**

线路位宽通常指的是计算机硬件中数据传输通道的宽度，也就是一次可以传输的数据位数（bit）。比如内存总线、数据总线或地址总线的位宽。线路位宽直接影响数据传输的效率：

**CPU位宽**

CPU位宽一般指的是CPU的**寄存器宽度**或**数据处理能力**，也就是CPU一次能够处理的数据位数。常见的CPU位宽有8位、16位、32位和64位。它决定了：

假设一台电脑
- 64位CPU：说明它能处理64位数据，寻址能力达到2⁶⁴。
- 64位数据总线：CPU与内存之间一次传输64位数据。
这时，CPU和线路位宽匹配，性能最佳。如果总线只有32位，CPU需要两次传输才能拿到64位数据，效率会下降。

**4.程序执行的基本过程**

![image-20250228154122107](assets/image-20250228154122107.png)

一个程序执行的时候，CPU会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面实行，然后分局指令长度自增，开始顺序读取下一条指令。

CPU的指令周期：CPU从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束的过程。



**5.a=1 + 2执行具体过程**

编译器会把a=1 + 2翻译成四条指令，存放到正文段中。

![image-20250228160903844](assets/image-20250228160903844.png)

![image-20250228161054582](assets/image-20250228161054582.png)

编译完成之后，具体执行程序的时候，程序计数器会被设置为0x200地址，然后依次执行这四条指令



**指令**

不同的CPU有不同的指令集，也就是对应着不同的汇编语言和不同的机器码。

下面介绍MIPS指令集：

MIPS指令是一个32位的整数，高6位代表着操作码，剩下26位不同指令类型所表示的内容也就不相同

![image-20250228162052023](assets/image-20250228162052023.png)

R型指令：操作数全部来自寄存器，计算结果也存储到寄存器中。

I型指令：一个操作数来自寄存器，另一个是立即数（直接嵌入指令中的常量），结果存储到寄存器中。

J型指令：用于无条件跳转，跳转目标地址通过立即数计算得出，通常不涉及寄存器操作数的计算。

![image-20250228163037467](assets/image-20250228163037467.png)

指令周期：

1.CPU通过程序计数器读取对应内存地址的指令，这个部分称为Fetch（取得指令）；
2.CPU对指令进行解码，这个部分称为Decode（指令译码）；
3.CPU执行指令，这个部分称为Execution（执行指令）；
4.CPU将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为Store（数据回写）；

![image-20250228221710463](assets/image-20250228221710463.png)

Fetch：指令是存放再存储器里的，实际上，通过程序计数器和指令寄存器取出指令的过程，是由控制器操作的。

Decode：控制器

Execution：算数逻辑单元（运算器）。但是如果是一个简单的无条件地址跳转，则是直接在控制器里面完成的，不需要用到运算器。



**指令的类型**

- 数据传输类型：比如store/load是寄存器与内存间数据传输的指令，mov是将一个内存地址的数据移动到另一个内存地址的指令；
- 运算类型：比如加减乘除、位运算、比较大小等等，它们最多只能处理两个寄存器中的数据
- 跳转类型：通过修改程序计数器的值来达到跳转执行指令的过程
- 信号类型：发生中断的指令trap
- 闲置类型：比如指令nop

**指令的执行速度**
$$
程序的CPU执行时间=CPU时钟周期数 \times 时钟周期时间
$$
时钟周期时间就是CPU主频，主频越高就说明CPU的工作速度就越快，比如2.4GHz

对于时钟周期数，可以分为指令数 x 每条指令的平均时钟周期数（Cycles Per Instruction, 简称CPI）

于是
$$
程序的CPU执行时间=指令数\times CPI \times时钟周期时间
$$
指令数，就是执行程序所需要多少条指令，以及哪些指令。这个的层面在于编译器来优化，因为同样的代码，在不同的编译器，编译出来的计算机指令会有各种不同的表示方式。

CPI，表示一条指令需要多少个时钟周期数

时钟周期时间，表示计算机主频，取决于计算机硬件。

**总结：**

1、64位相比32位CPU的优势在哪里？64位CPU的计算性能一定比32位CPU高很多吗？

- 更大的寻址能力：32位CPU的地址空间是2³²字节（约4GB），也就是说它最多只能直接寻址4GB的内存。64位CPU的地址空间是2⁶⁴字节（约18亿GB），理论上支持几乎无限大的内存。

- 更宽的寄存器：64位CPU的寄存器是64位宽，可以一次处理64位的数据，而32位CPU只能处理32位。

不一定，计算性能的提升并非单纯由位宽决定，还取决于以下因素：主频、架构设计

2、软件的32位和64位之间的区别？32位的操作系统可以运行在64位的电脑上吗？64位的操作系统可以运行在32位的电脑上吗？如果不行，原因是什么？

32位：寄存器、数据总线、地址总线为32位，内存寻址上限4GB。

64位：寄存器、数据总线、地址总线为64位，内存寻址上限理论上2⁶⁴字节。

32位指令在64位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是如果64位指令在32位机器上执行，就比较苦难了，因为32位的寄存器存不下64位的指令。

硬件的64位和32位值得四CPU的位宽，软件的64位和32位指的是指令的位宽。
